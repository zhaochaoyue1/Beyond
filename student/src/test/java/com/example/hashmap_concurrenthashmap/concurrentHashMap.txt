1. 
    [java.util.concurrent.ConcurrentHashMap.spread()]()
    ``
        static final int spread(int h) {
            //这个方法通过对哈希值h进行无符号右移16位，然后与原始哈希值进行异或操作，
            //最后再与HASH_BITS进行按位与操作。其中，HASH_BITS是一个常量，
            //用于限制哈希值的范围0x7fffffff，即十六进制表示的2147483647。这个值用于限制哈希值的范围，确保哈希值始终为正数。
            return (h ^ (h >>> 16)) & HASH_BITS;
        }
    ``

2. 为什么HashMap不通过HASH_BITS限制范围呢？

   HashMap不需要像ConcurrentHashMap那样限制哈希范围，是因为在HashMap中， 
   哈希值的范围已经通过取模运算（%操作）限制在数组的长度范围内。HashMap内部使用哈希值对数组长度取模，
   将元素放入对应的数组位置，因此不需要额外的哈希范围限制。这种设计可以更好地利用数组的空间，而不需要额外的位运算来限制哈希值的范围。

3. initTable()

   ``private final Node<K,V>[] initTable() {
           Node<K,V>[] tab; int sc;
           //则根据sizeCtl的值进行初始化。sizeCtl是一个用于控制表的大小的字段。
           //在初始化过程中，它首先检查sizeCtl的值，如果小于0，表示有其他线程正在进行初始化，
           //此时会让出CPU资源。如果sizeCtl大于等于0，并且成功将sizeCtl设置为-1（表示当前线程正在进行初始化），
           //则会根据sizeCtl的值确定初始化的大小，并创建一个新的Node数组作为哈希表。
           //最后，通过将sizeCtl设置为计算后的阈值，完成初始化并返回哈希表。这段代码确保了在并发情况下对哈希表的安全初始化。
           while ((tab = table) == null || tab.length == 0) {
               if ((sc = sizeCtl) < 0)
                   `Thread.yield()` 是一个静态方法，它的作用是提示调度器当前线程愿意放弃当前的 CPU 时间片，
                    使得其他具有相同优先级的线程有机会执行。调用`Thread.yield()`并不会导致当前线程进入阻塞状态，
                    而是仅仅是一个提示，调度器可以选择忽略这个提示。
                    一般来说，`Thread.yield()`的使用是比较少见的，因为它依赖于特定的调度器实现，
                    不同的操作系统和JVM可能对其行为有不同的解释。在大多数情况下，更好的做法是通过合适的并发控制机制
                   （比如锁、条件变量、信号量等）来实现线程之间的协作和调度。
                   Thread.yield(); // lost initialization race; just spin
               else if (U.compareAndSwapInt(this, SIZECTL, sc, -1)) {
                   try {
                       if ((tab = table) == null || tab.length == 0) {
                           int n = (sc > 0) ? sc : DEFAULT_CAPACITY;
                           @SuppressWarnings("unchecked")
                           Node<K,V>[] nt = (Node<K,V>[])new Node<?,?>[n];
                           table = tab = nt;
                           sc = n - (n >>> 2);
                       }
                   } finally {
                       sizeCtl = sc;
                   }
                   break;
               }
           }
           return tab;
   }``

4. sun.misc.Unsafe 对象的是用来处理什么的？

    sun.misc.Unsafe 是一个非常特殊的类，它提供了直接操作内存和执行特定机器指令的能力，
    这些操作通常是由Java语言所限制的。它允许Java程序直接访问内存地址、修改对象的字段值、
    分配内存、执行CAS（Compare And Swap）操作等。由于它的功能非常强大且容易导致不安全的操作，
    因此它被标记为 "Unsafe"，并且不建议在普通的Java应用程序中使用。

    在一些特定的情况下，比如Java标准库或者一些高性能框架，可能会使用sun.misc.Unsafe来进行一些高效的操作，
    但这需要非常小心地处理，因为不当的使用可能导致内存泄漏、数据损坏或者安全漏洞。因此，一般情况下，
    开发者应该尽量避免直接使用sun.misc.Unsafe，而是通过更安全的方式来实现相同的功能。

5. 在 `ConcurrentHashMap` 的 `putVal` 方法中，`(fh = f.hash) == MOVED`
   这个判断是用来检查当前节点的哈希值是否等于 `MOVED`。这里的 `MOVED` 是一个常量，通常用来表示节点已经被移动到新位置的状态。
   如果当前节点的哈希值等于 `MOVED`，那么说明该节点已经被移动到了新的位置，因此需要重新定位并插入该节点。
   这个判断的作用是在并发情况下，确保节点被正确地插入到新的位置，以保证并发安全性。

6. ```
   final Node<K,V>[] helpTransfer(Node<K,V>[] tab, Node<K,V> f) {
       Node<K,V>[] nextTab; // 声明一个Node数组nextTab
       int sc; // 声明一个整型变量sc
       if (tab != null && (f instanceof ForwardingNode) && // 如果当前表不为空，并且节点f是转发节点
           (nextTab = ((ForwardingNode<K,V>)f).nextTable) != null) { // 并且转发节点的下一个表nextTab也不为空
           int rs = resizeStamp(tab.length); // 计算扩容标识rs
           while (nextTab == nextTable && table == tab && // 当nextTab等于nextTable且table等于tab
                  (sc = sizeCtl) < 0) { // 且sizeCtl小于0时循环
               if ((sc >>> RESIZE_STAMP_SHIFT) != rs || sc == rs + 1 || // 如果右移RESIZE_STAMP_SHIFT位后的sc不等于rs，或者sc等于rs+1
                   sc == rs + MAX_RESIZERS || transferIndex <= 0) // 或者sc等于rs+MAX_RESIZERS，或者transferIndex小于等于0
                   break; // 跳出循环
               if (U.compareAndSwapInt(this, SIZECTL, sc, sc + 1)) { // 使用CAS操作增加sizeCtl
                   transfer(tab, nextTab); // 执行表的转移操作
                   break; // 跳出循环
               }
           }
           return nextTab; // 返回nextTab
       }
       return table; // 如果条件不满足，返回table
   }
   ```